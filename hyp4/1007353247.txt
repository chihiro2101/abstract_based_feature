these systems may or may not allow other applications to access the data directly , and those that did use a wide variety of methodologies since the sql language had only rudimentary programming features , users often wanted to use sql within a program written in another language , say fortran or c this led to the concept of embedded sql , which allowed sql code to be embedded within another language results returned from the statements would be interpreted back into c data formats like char using similar library code like the different varieties of sql , the embedded sqls that used them varied widely , not only from platform to platform , but even across languages on one platform – a system that allowed calls into ibm 's db2 would look very different from one that called into their own sql/ds another key problem to the embedded sql concept was that the sql code could only be changed in the program 's source code , so that even small changes to the query required considerable programmer effort to modify the sql market referred to this as static sql , versus dynamic sql which could be changed at any time , like the command-line interfaces that shipped with almost all sql systems , or a programming interface that left the sql as plain text until it was called older mainframe databases , and the newer microcomputer based systems that were based on them , generally did not have a sql-like command processor between the user and the database engine instead , the data was accessed directly by the program – a programming library in the case of large mainframe systems , or a command line interface or interactive forms system in the case of dbase and similar applications for this model to work , a data access standard was a requirement – in the mainframe field it was highly likely that all of the computers in a shop were from one vendor and clients were computer terminals talking directly to them , but in the micro field there was no such standardization and any client might access any server using any networking system blueprint , developed for 1-2-3 , supported a variety of data sources , including sql/ds , db2 , focus and a variety of similar mainframe systems , as well as microcomputer systems like dbase and the early microsoft/ashton-tate efforts that would eventually develop into microsoft sql server 1 , 69 unlike the later odbc , blueprint was a purely code-based system , lacking anything approximating a command language like sql much of the system was based on sybase 's db-library system , with the sybase-specific sections removed and several additions to support other platforms in 1988 several vendors , mostly from the unix and database communities , formed the sql access group ( sag ) in an effort to produce a single basic standard for the sql language at the first meeting there was considerable debate over whether or not the effort should work solely on the sql language itself , or attempt a wider standardization which included a dynamic sql language-embedding system as well , what they called a call level interface ( cli ) the new sqlc '' gang of four '' , ms , tandem , dec and sybase , brought an updated version of sqlc to the next sag meeting in june 1990 the sag responded by opening the standard effort to any competing design , but of the many proposals , only oracle corp had a system that presented serious competition in the end , sqlc won the votes and became the draft standard , but only after large portions of the api were removed – the standards document was trimmed from 120 pages to 50 during this time iso/iec 9075-3 – information technology – database languages – sql – part 3 : call-level interface ( sql/cli ) the sag itself was taken over by the x/open group in 1996 , and , over time , became part of the open group 's common application environment a proposed standard was released in december 1991 , and industry input was gathered and worked into the system through 1992 , resulting in yet another name change to odbc during this time , microsoft was in the midst of developing their jet database system however , jet did not use sql ; like datalens , the interface was in c and consisted of data structures and function calls this would not only make windows a premier platform for cli development , but also allow users to use sql to access both jet and other databases as well it is not uncommon to find odbc drivers for database engines that are meant to be embedded , like sqlite , as a way to allow existing tools to act as front-ends to these engines for testing and debugging in these scenarios , there is no direct client-side access nor multiple client software systems to support ; everything goes through the programmer-supplied html application an odbc-jdbc bridge consists of an odbc driver which uses the services of a jdbc driver to connect to a database programmers usually use such a bridge when they lack an odbc driver for some database but have access to a jdbc driver programmers usually use such a bridge when a given database lacks a jdbc driver , but is accessible through an odbc driver programmers usually use such a bridge when a given database lacks an ole db provider , but is accessible through an odbc driver third parties have also developed such , notably openlink software whose 64-bit ole db provider for odbc data sources filled the gap when microsoft initially deprecated this bridge for their 64-bit os an ado.net-odbc bridge consists of an ado.net provider which uses the services of an odbc driver to connect to a target database 