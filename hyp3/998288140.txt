, implementing the traversal across a container , applying the given function to every element in turn external iterators and the iterator pattern there must also be a way to create an iterator so it points to some first element as well as some way to determine when the iterator has exhausted all of the elements in the container depending on the language and intended use , iterators may also provide additional operations or exhibit different behaviors the primary purpose of an iterator is to allow a user to process every element of a container while isolating the user from the internal structure of the container an iterator class is usually designed in tight coordination with the corresponding container class usually , the container provides the methods for creating iterators these functions still require explicit iterator objects as their initial input , but the subsequent iteration does not expose an iterator object to the user an iterator may allow the container object to be modified without invalidating the iterator this assertion must however be taken with a grain of salt , because more often than not , for efficiency reasons , the iterator implementation is so tightly bound to the container that it does preclude modification of the underlying container without invalidating itself this is usually not desirable , because many algorithms using the iterators invoke the iterators data access operation more often than the advance method 