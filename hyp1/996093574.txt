using the command design pattern can solve these problems : coupling the invoker of a request to a particular request should be avoided it should be possible to configure an object ( that invokes a request ) with a request implementing ( hard-wiring ) a request directly into a class is inflexible because it couples the class to a particular request at compile-time , which makes it impossible to specify a request at run-time using the command design pattern describes the following solution : define separate ( command ) objects that encapsulate a request a class delegates a request to a command object instead of implementing a particular request directly this enables one to configure a class with a command object that is used to perform a request the class is no longer coupled to a particular request and has no knowledge ( is independent ) of how the request is carried out instead , invoker refers to the command interface to perform a request ( command.execute ( ) ) , which makes the invoker independent of how the request is performed the uml sequence diagram shows the run-time interactions : the invoker object calls execute ( ) on a command1 object command1 calls action1 ( ) on a receiver1 object , which performs the request ; macro recording : if all user actions are represented by command objects , a program can record a sequence of actions simply by keeping a list of the command objects as they are executed ; multi-level undo : if all user actions in a program are implemented as command objects , the program can keep a stack of the most recently executed commands when the user wants to undo a command , the program simply pops the most recent command object and executes its method for example , to undo a delete selection command , the object may contain a copy of the deleted text so that it can be re-inserted , if the delete selection command must be undone it may refer to running the code identified by the command object 's execute method the receiver object owns the method that is called by the command 's execute method on the other hand , if the code is defined by the command object itself , the target object will be a different object entirely as a result , the command object no longer contains a reference to the target object nor a reference to the application code 