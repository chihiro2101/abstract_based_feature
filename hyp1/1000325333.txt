for even moderate sized rules and facts knowledge-bases , this naive approach performs far too slowly the rete algorithm provides the basis for a more efficient implementation a rete-based expert system builds a network of nodes , where each node ( except the root ) corresponds to a pattern occurring in the left-hand-side ( the condition part ) of a rule each node has a memory of facts which satisfy that pattern when a fact or combination of facts causes all of the patterns for a given rule to be satisfied , a leaf node is reached and the corresponding rule is triggered rete was first used as the core engine of the ops5 production system language which was used to build early systems including r1 for digital equipment corporation the same word is used in modern italian to mean network charles forgy has reportedly stated that he adopted the term 'rete ' because of its use in anatomy to describe a network of blood vessels and nerve fibers '' rete algorithm demystified ! â€“ part 1 '' by carole-ann matignon the rete algorithm is designed to sacrifice memory for increased speed the rete algorithm provides a generalized logical description of an implementation of functionality responsible for matching data tuples ( '' facts '' ) against productions ( '' rules '' ) in a pattern-matching production system ( a category of rule engine ) a production consists of one or more conditions and a set of actions which may be undertaken for each complete set of facts that match the conditions the rete algorithm exhibits the following major characteristics : it reduces or eliminates certain types of redundancy through the use of node sharing it allows for efficient removal of memory elements when facts are retracted from working memory the rete algorithm is widely used to implement matching functionality within pattern-matching engines that exploit a match-resolve-act cycle to support forward chaining and inference rete networks act as a type of relational query processor , performing projections , selections and joins conditionally on arbitrary numbers of data tuples productions ( rules ) are typically captured and defined by analysts and developers using some high-level rules language when facts are '' asserted '' to working memory , the engine creates working memory elements ( wmes ) for each fact facts are n-tuples , and may therefore contain an arbitrary number of data items each wme may hold an entire n-tuple , or , alternatively , each fact may be represented by a set of wmes where each wme contains a fixed-length tuple the root node passes each wme on to its child nodes , and each wme may then be propagated through the network , possibly being stored in intermediate memories , until it arrives at a terminal node nodes in the discrimination network may also perform tests that compare two or more attributes of the same wme within the discrimination network , each branch of alpha nodes ( also called 1-input nodes ) terminates at a memory , called an alpha memory wmes that fail to match at least one condition in a branch are not materialised within the corresponding alpha memory alpha node branches may fork in order to minimise condition redundancy in descriptions of rete , it is common to refer to token passing within the beta network as any one wme list passes through the beta network , new wmes may be added to it , and the list may be stored in beta memories a wme list in a beta memory represents a partial match for the conditions in a given production each terminal node represents a single production , and each wme list that arrives at a terminal node represents a complete set of matching wmes for the conditions in that production an alpha memory holds wm and performs '' right '' activations on the beta node each time it stores a new wme when a join node is right-activated , it compares one or more attributes of the newly stored wme from its input alpha memory against given attributes of specific wmes in each wme list contained in the input beta memory each beta node outputs wme lists which are either stored in a beta memory or sent directly to a terminal node logically , a beta node at the head of a branch of beta nodes is a special case because it takes no input from any beta memory higher in the network some engines use specialised adapter nodes to connect alpha memories to the left input of beta nodes in both cases , '' head '' beta nodes take their input from two alpha memories in order to eliminate node redundancies , any one alpha or beta memory may be used to perform activations on multiple beta nodes as well as join nodes , the beta network may contain additional node types , some of which are described below during any one match-resolve-act cycle , the engine will find all possible matches for the facts currently asserted to working memory conflict resolution is not defined as part of the rete algorithm , but is used alongside the algorithm each time any single production instance performs one or more such changes , the engine immediately enters a new match-resolve-act cycle the engine undertakes matching of the changed data which , in turn , may result in changes to the list of production instances on the agenda some engines support advanced refraction strategies in which certain production instances executed in a previous cycle are not re-executed in the new cycle , even though they may still exist on the agenda it is possible for the engine to enter into never-ending loops in which the agenda never reaches the empty state some of the optimisations offered by rete networks are only useful in scenarios where the engine performs multiple match-resolve-act cycles however , by implementing additional beta node types , it is possible for rete networks to perform quantifications some engines provide built-in justification systems in conjunction with their implementation of the rete algorithm in the 1980s , charles forgy developed a successor to the rete algorithm named rete ii 