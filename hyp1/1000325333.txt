a naïve algorithm of an expert system might check each rule against known facts in a knowledge base , firing that rule if necessary , then moving on to the next rule ( and looping back to the first rule when finished ) for even moderate sized rules and facts knowledge-bases , this naive approach performs far too slowly the rete algorithm provides the basis for a more efficient implementation a rete-based expert system builds a network of nodes , where each node ( except the root ) corresponds to a pattern occurring in the left-hand-side ( the condition part ) of a rule each node has a memory of facts which satisfy that pattern as new facts are asserted or modified , they propagate along the network , causing nodes to be annotated when that fact matches that pattern when a fact or combination of facts causes all of the patterns for a given rule to be satisfied , a leaf node is reached and the corresponding rule is triggered '' rete algorithm demystified ! – part 1 '' by carole-ann matignon the rete algorithm is designed to sacrifice memory for increased speed in most cases , the speed increase over naïve implementations is several orders of magnitude ( because rete performance is theoretically independent of the number of rules in the system ) in very large expert systems , however , the original rete algorithm tends to run into memory and server consumption problems the rete algorithm provides a generalized logical description of an implementation of functionality responsible for matching data tuples ( '' facts '' ) against productions ( '' rules '' ) in a pattern-matching production system ( a category of rule engine ) conditions test fact attributes , including fact type specifiers/identifiers the rete algorithm exhibits the following major characteristics : it reduces or eliminates certain types of redundancy through the use of node sharing this , in turn , allows production systems to avoid complete re-evaluation of all facts each time changes are made to the production system 's working memory it allows for efficient removal of memory elements when facts are retracted from working memory the rete algorithm is widely used to implement matching functionality within pattern-matching engines that exploit a match-resolve-act cycle to support forward chaining and inference they are generally represented at run-time using a network of in-memory objects rete networks act as a type of relational query processor , performing projections , selections and joins conditionally on arbitrary numbers of data tuples when facts are '' asserted '' to working memory , the engine creates working memory elements ( wmes ) for each fact facts are n-tuples , and may therefore contain an arbitrary number of data items the root node passes each wme on to its child nodes , and each wme may then be propagated through the network , possibly being stored in intermediate memories , until it arrives at a terminal node the '' right '' ( beta ) side of the graph chiefly performs joins between different wmes as any one wme list passes through the beta network , new wmes may be added to it , and the list may be stored in beta memories each terminal node represents a single production , and each wme list that arrives at a terminal node represents a complete set of matching wmes for the conditions in that production for each wme list it receives , a production node will '' activate '' a new production instance on the '' agenda '' an alpha memory holds wm and performs '' right '' activations on the beta node each time it stores a new wme a beta memory holds wme lists and performs '' left '' activations on the beta node each time it stores a new wme list when a join node is left-activated it traverses a single newly stored wme list in the beta memory , retrieving specific attribute values of given wmes logically , a beta node at the head of a branch of beta nodes is a special case because it takes no input from any beta memory higher in the network other engines allow beta nodes to take input directly from two alpha memories , treating one as a '' left '' input and the other as a '' right '' input in this case , there may be no need to store wmes in alpha memories during any one match-resolve-act cycle , the engine will find all possible matches for the facts currently asserted to working memory this is termed conflict resolution , and the list of activated production instances is termed the conflict set conflict resolution is not defined as part of the rete algorithm , but is used alongside the algorithm having performed conflict resolution , the engine now '' fires '' the first production instance , executing a list of actions associated with the production each production instance will fire only once , at most , during any one match-resolve-act cycle updates are represented by retracting and then re-asserting the wme as part of the new match-resolve-act cycle , the engine performs conflict resolution on the agenda and then executes the current first instance the engine continues to fire production instances , and to enter new match-resolve-act cycles , until no further production instances exist on the agenda they may also provide automatic loop detection in which never-ending loops are automatically halted after a given number of iterations as for conflict resolution , the firing of activated production instances is not a feature of the rete algorithm however , it is a central feature of engines that use rete networks the rete algorithm does not define any approach to justification justification refers to mechanisms commonly required in expert and decision systems in which , at its simplest , the system reports each of the inner decisions used to reach some final conclusion this article does not provide an exhaustive description of every possible variation or extension of the rete algorithm in 2010 , forgy developed a new generation of the rete algorithm 