suppose a library has 10 identical study rooms , to be used by one student at a time students must request a room from the front desk if they wish to use a study room when a student has finished using a room , the student must return to the desk and indicate that one room has become free the value of the semaphore in this scenario is initially 10 , with all rooms empty when a student requests a room , they are granted access , and the value of the semaphore is changed to 9 if someone requests a room and the current value of the semaphore is 0 , the little book of semaphores allen b if one of the rooms was released , but there are several students waiting , then any method can be used to select the one who will occupy the room ( like fifo or flipping a coin ) the librarian above may turn the lights off in the study hall when there are no students remaining , or may place a sign that says the rooms are very busy when most of the rooms are occupied the v operation is the inverse : it makes a resource available again after the process has finished using it one important property of semaphore s is that its value can not be changed except by using the v and p operations if the new value of the semaphore variable is negative , the process executing is blocked ( i.e otherwise , the process continues execution , having used a unit of the resource after the increment , if the pre-increment value was negative ( meaning there are processes waiting for a resource ) , it transfers a blocked process from the semaphore 's waiting queue to the ready queue the counting semaphore concept can be extended with the ability to claim or return more than one '' unit '' from the semaphore , a technique implemented in unix if a process performs a p operation on a semaphore that has the value zero , the process is added to the semaphore 's queue and its execution is suspended atomicity may be achieved by using a machine instruction that is able to read-modify-write the semaphore in a single operation the semaphore solution to the producerâ€“consumer problem tracks the state of the queue with two semaphores : emptycount , the number of empty places in the queue , and fullcount , the number of elements in the queue the producers , one at a time , gain access to the queue through usequeue and deposit items in the queue note that emptycount may be much lower than the actual number of empty places in the queue , for example in the case where many producers have decremented it but are waiting their turn on usequeue before filling empty places recursion deadlock : a task is allowed to lock a reentrant mutex multiple times as it unlocks it an equal number of times 