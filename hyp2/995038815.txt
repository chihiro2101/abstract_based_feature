suppose a library has 10 identical study rooms , to be used by one student at a time when a student has finished using a room , the student must return to the desk and indicate that one room has become free when a student requests a room , the clerk decreases this number in this scenario the front desk count-holder represents a counting semaphore , the rooms are the resource , and the students represent processes/threads the value of the semaphore in this scenario is initially 10 , with all rooms empty when a student requests a room , they are granted access , and the value of the semaphore is changed to 9 when used to control access to a pool of resources , a semaphore tracks only how many resources are free ; it does not keep track of which of the resources are free counting semaphores are equipped with two operations , historically denoted as p and v ( see for alternative names ) the value of the semaphore s is the number of units of the resource that are currently available the p operation wastes time or sleeps until a resource protected by the semaphore becomes available , at which time the resource is immediately claimed the v operation is the inverse : it makes a resource available again after the process has finished using it one important property of semaphore s is that its value can not be changed except by using the v and p operations a simple way to understand ( p ) and ( v ) operations is : : decrements the value of semaphore variable by 1 otherwise , the process continues execution , having used a unit of the resource after the increment , if the pre-increment value was negative ( meaning there are processes waiting for a resource ) , it transfers a blocked process from the semaphore 's waiting queue to the ready queue many operating systems provide efficient semaphore primitives that unblock a waiting process when the semaphore is incremented this means that processes do not waste time checking the semaphore value unnecessarily to avoid starvation , a semaphore has an associated queue of processes ( usually with fifo semantics ) to solve this problem in a multiprocessor system a locking variable can be used to control access to the semaphore the producers , one at a time , gain access to the queue through usequeue and deposit items in the queue 