although shapes themselves ( particularly paths ) can be decomposed further into nodes such as spline nodes , it is practical to think of the scene graph as composed of shapes rather than going to a lower level of representation internally , there may be no real structural difference between layers and groups at all , since they are both just nodes of a scene graph a visibility member , for example , would be a feature of a layer , but not necessarily of a group in such applications , nodes in a scene graph ( generally ) represent entities or objects in the scene for instance , a game might define a logical relationship between a knight and a horse so that the knight is considered an extension to the horse the scene graph may also describe the spatial , as well as the logical , relationship of the various entities : the knight moves through 3d space as the horse moves in these large applications , memory requirements are major considerations when designing a scene graph this means that only a single copy of the data is kept , which is then referenced by any 'knight ' nodes in the scene graph the simplest form of scene graph uses an array or linked list data structure , and displaying its shapes is simply a matter of linearly iterating the nodes one by one other common operations , such as checking to see point location are also done via linear searches applying an operation on a scene graph requires some way of dispatching an operation based on a node 's type for example , in a render operation , a transformation group node would accumulate its transformation by matrix multiplication , vector displacement , quaternions or euler angles if the node is a transformation node , it adds its own transformation to the current transformation matrix once the operation finishes traversing all the children of a node , it calls the node 's post-render operation so that the transformation node can undo the transformation some scene graph operations are actually more efficient when nodes are traversed in a different order â€“ this is where some systems implement scene graph rebuilding to reorder the scene graph into an easier-to-parse format or tree for example , in 2d cases , scene graphs typically render themselves by starting at the tree 's root node and then recursively draw the child nodes at the bottom of the hierarchy , the size of the volume is just large enough to encompass a single object tightly ( or possibly even some smaller fraction of an object in high resolution bvhs ) if an object 's bounding volume does not intersect a volume higher in the tree , it can not intersect any object below that node ( so they are all rejected very quickly ) the hoops 3d graphics system appears to have been the first commercial scene graph library provided by a single software vendor graph ( data structure ) graph theory space partitioning tree ( data structure ) 