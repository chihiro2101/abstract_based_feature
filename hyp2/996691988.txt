there exists a class of universal computers with a single instruction based on bit manipulation such as bit copying or bit inversion since their memory model is finite , as is the memory structure used in real computers , those bit manipulation machines are equivalent to real computers rather than to turing machines oleg mazonka , '' bit copying : the ultimate computational simplicity '' , complex systems journal 2011 , vol 19 , n3 , pp 263â€“285 currently known oiscs can be roughly separated into three broad categories : bit-manipulating machines transport triggered architecture machines arithmetic-based turing-complete machines a bit copying machine , called bitbitjump , copies one bit in memory and passes the execution unconditionally to the address specified by one of the operands of the instruction being able to execute any algorithm and to interpret any other universal machine ) because copying bits can conditionally modify the code that will be subsequently executed another machine , called the toga computer , inverts a bit and passes the execution conditionally depending on the result of inversion for example , in an oisc using a single memory-to-memory copy instruction , this is done by triggering ports that perform arithmetic and instruction pointer jumps when written to hence , there is no need for an opcode to identify which instruction to execute ; the choice of instruction is inherent in the design of the machine , and an oisc is typically named after the instruction it uses ( e.g each of the above instructions can be used to construct a turing-complete oisc for example , one variation known as dln ( decrement and jump if not zero ) has only two operands and uses decrement as the base operation the instruction ( '' subtract and branch if less than or equal to zero '' ) subtracts the contents at address from the contents at address , stores the result at address , and then , if the result is not positive , transfers control to address ( if the result is positive , execution proceeds to the next instruction in sequence ) , the following instructions result in the content at location being added to the content at location : ; : subleq a , z subleq z , b subleq z , z the first instruction subtracts the content at location from the content at location ( which is 0 ) and stores the result ( which is the negative of the content at in location subleq2 can also be used to synthesize higher-order instructions , although it generally requires more operations for a given task there is a compiler called higher subleq written by oleg mazonka that compiles a simplified c program into code in a reverse subtract and skip if borrow ( rssb ) instruction , the accumulator is subtracted from the memory location and the next instruction is skipped if there was a borrow ( memory location was smaller than the accumulator ) a transport triggered architecture uses only the move instruction , hence it was originally called a '' move machine '' so memory cells are not simple store but coupled with an arithmetic logic unit ( alu ) setup to perform only one sort of operation with the current value of the cell a commercial transport triggered architecture microcontroller has been produced called maxq , which hides the apparent inconvenience of an oisc by using a '' transfer map '' that represents all possible destinations for the move instructions 