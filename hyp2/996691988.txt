there exists a class of universal computers with a single instruction based on bit manipulation such as bit copying or bit inversion since their memory model is finite , as is the memory structure used in real computers , those bit manipulation machines are equivalent to real computers rather than to turing machines 263â€“285 currently known oiscs can be roughly separated into three broad categories : bit-manipulating machines transport triggered architecture machines arithmetic-based turing-complete machines a bit copying machine , called bitbitjump , copies one bit in memory and passes the execution unconditionally to the address specified by one of the operands of the instruction another machine , called the toga computer , inverts a bit and passes the execution conditionally depending on the result of inversion for example , in an oisc using a single memory-to-memory copy instruction , this is done by triggering ports that perform arithmetic and instruction pointer jumps when written to hence , there is no need for an opcode to identify which instruction to execute ; the choice of instruction is inherent in the design of the machine , and an oisc is typically named after the instruction it uses ( e.g however , it is possible to construct turing complete machines using an instruction based on other arithmetic operations , e.g the instruction ( '' subtract and branch if less than or equal to zero '' ) subtracts the contents at address from the contents at address , stores the result at address , and then , if the result is not positive , transfers control to address ( if the result is positive , execution proceeds to the next instruction in sequence ) a variant is also possible with two operands and an internal accumulator , where the accumulator is subtracted from the memory location specified by the first operand it is possible to synthesize many types of higher-order instructions using only the instruction unconditional branch : ; : subleq z , z , c addition can be performed by repeated subtraction , with no conditional branching ; e.g , the following instructions result in the content at location being added to the content at location : ; : subleq a , z subleq z , b subleq z , z the first instruction subtracts the content at location from the content at location ( which is 0 ) and stores the result ( which is the negative of the content at in location the second instruction subtracts this result from , storing in this difference ( which is now the sum of the contents originally at and ; the third instruction restores the value 0 to , the following instructions result in the content at location getting replaced by the content at location , again assuming the content at location is maintained as 0 : ; : subleq b , b subleq a , z subleq z , b subleq z , z any desired arithmetic test can be built for example , a branch-if-zero condition can be assembled from the following instructions : ; : subleq b , z , l1 subleq z , z , out l1 : subleq z , z subleq z , b , c out : the instruction ( '' subtract and branch if negative '' ) , also called , is defined similarly to : subneg a , b , c ; memb memb - mema ; if ( memb conditional branching can be suppressed by setting the third operand equal to the address of the next instruction in sequence the machine is able to do one operation : take from location x as many counters as there are in location y and transfer them to location z and proceed to next instruction this instruction moves the contents of one memory location to another memory location combining with the current content of the new location : move a to b ; memb : mema ( + , - , , / , 