in a turing completeness , each memory location can store an arbitrary integer , anddepending on the modelthere may be arbitrarily many locations there exists a class of universal computers with a single instruction based on bit manipulation such as bit copying or bit inversion since their memory model is finite , as is the memory structure used in real computers , those bit manipulation machines are equivalent to real computers rather than to turing machines a bit copying machine , called bitbitjump , copies one bit in memory and passes the execution unconditionally to the address specified by one of the operands of the instruction being able to execute any algorithm and to interpret any other universal machine ) because copying bits can conditionally modify the code that will be subsequently executed another machine , called the toga computer , inverts a bit and passes the execution conditionally depending on the result of inversion the unique instruction is toga ( a , b ) which stands for toggle a and branch to b if the result of the toggle operation is true usually , some memory registers ( triggering ports ) within common address space perform an assigned operation when the instruction references them for example , in an oisc using a single memory-to-memory copy instruction , this is done by triggering ports that perform arithmetic and instruction pointer jumps when written to hence , there is no need for an opcode to identify which instruction to execute ; the choice of instruction is inherent in the design of the machine , and an oisc is typically named after the instruction it uses ( e.g for example , one variation known as dln ( decrement and jump if not zero ) has only two operands and uses decrement as the base operation the sbnz a , b , c , d instruction ( '' subtract and branch if not equal to zero '' ) subtracts the contents at address a from the contents at address b , stores the result at address c , and then , if the result is not 0 , transfers control to address d ( if the result is equal to zero , execution proceeds to the next instruction in sequence ) the instruction ( '' subtract and branch if less than or equal to zero '' ) subtracts the contents at address from the contents at address , stores the result at address , and then , if the result is not positive , transfers control to address ( if the result is positive , execution proceeds to the next instruction in sequence ) pseudocode : subleq a , b , c ; memb memb - mema ; if ( memb â‰¤ 0 ) goto c conditional branching can be suppressed by setting the third operand equal to the address of the next instruction in sequence unconditional branch : ; : subleq z , z , c addition can be performed by repeated subtraction , with no conditional branching ; e.g , the following instructions result in the content at location being added to the content at location : ; : subleq a , z subleq z , b subleq z , z the first instruction subtracts the content at location from the content at location ( which is 0 ) and stores the result ( which is the negative of the content at in location , the following instructions result in the content at location getting replaced by the content at location , again assuming the content at location is maintained as 0 : ; : subleq b , b subleq a , z subleq z , b subleq z , z any desired arithmetic test can be built there is a compiler called higher subleq written by oleg mazonka that compiles a simplified c program into code this instruction moves the contents of one memory location to another memory location combining with the current content of the new location : move a to b ; memb : mema ( + , - , , / , 