in a turing completeness , each memory location can store an arbitrary integer , anddepending on the modelthere may be arbitrarily many locations there exists a class of universal computers with a single instruction based on bit manipulation such as bit copying or bit inversion since their memory model is finite , as is the memory structure used in real computers , those bit manipulation machines are equivalent to real computers rather than to turing machines oleg mazonka , '' bit copying : the ultimate computational simplicity '' , complex systems journal 2011 , vol 19 , n3 , pp 263–285 currently known oiscs can be roughly separated into three broad categories : bit-manipulating machines transport triggered architecture machines arithmetic-based turing-complete machines a bit copying machine , called bitbitjump , copies one bit in memory and passes the execution unconditionally to the address specified by one of the operands of the instruction this process turns out to be capable of universal computation ( i.e being able to execute any algorithm and to interpret any other universal machine ) because copying bits can conditionally modify the code that will be subsequently executed another machine , called the toga computer , inverts a bit and passes the execution conditionally depending on the result of inversion for example , in an oisc using a single memory-to-memory copy instruction , this is done by triggering ports that perform arithmetic and instruction pointer jumps when written to like the two previous universal computers , this class is also turing-complete hence , there is no need for an opcode to identify which instruction to execute ; the choice of instruction is inherent in the design of the machine , and an oisc is typically named after the instruction it uses ( e.g , an sbn oisc , the subleq language , etc each of the above instructions can be used to construct a turing-complete oisc for example , one variation known as dln ( decrement and jump if not zero ) has only two operands and uses decrement as the base operation subleq2 can also be used to synthesize higher-order instructions , although it generally requires more operations for a given task the machine is able to do one operation : take from location x as many counters as there are in location y and transfer them to location z and proceed to next instruction a proof of which was given by lambek on an equivalent two instruction machine : x+ ( increment x ) and x− else t ( decrement x if it not empty , else jump to t ) cryptoleq is a language consisting of one eponymous instruction , is capable of performing general-purpose computation on encrypted programs and is a close relative to subleq 