in a turing completeness , each memory location can store an arbitrary integer , anddepending on the modelthere may be arbitrarily many locations there exists a class of universal computers with a single instruction based on bit manipulation such as bit copying or bit inversion since their memory model is finite , as is the memory structure used in real computers , those bit manipulation machines are equivalent to real computers rather than to turing machines a bit copying machine , called bitbitjump , copies one bit in memory and passes the execution unconditionally to the address specified by one of the operands of the instruction being able to execute any algorithm and to interpret any other universal machine ) because copying bits can conditionally modify the code that will be subsequently executed another machine , called the toga computer , inverts a bit and passes the execution conditionally depending on the result of inversion the unique instruction is toga ( a , b ) which stands for toggle a and branch to b if the result of the toggle operation is true for example , in an oisc using a single memory-to-memory copy instruction , this is done by triggering ports that perform arithmetic and instruction pointer jumps when written to the instruction operates on integers which may also be addresses in memory hence , there is no need for an opcode to identify which instruction to execute ; the choice of instruction is inherent in the design of the machine , and an oisc is typically named after the instruction it uses ( e.g , an sbn oisc , the subleq language , etc however , it is possible to construct turing complete machines using an instruction based on other arithmetic operations , e.g a variant is also possible with two operands and an internal accumulator , where the accumulator is subtracted from the memory location specified by the first operand the second instruction subtracts this result from , storing in this difference ( which is now the sum of the contents originally at and ; the third instruction restores the value 0 to subleq2 can also be used to synthesize higher-order instructions , although it generally requires more operations for a given task the machine is able to do one operation : take from location x as many counters as there are in location y and transfer them to location z and proceed to next instruction in a reverse subtract and skip if borrow ( rssb ) instruction , the accumulator is subtracted from the memory location and the next instruction is skipped if there was a borrow ( memory location was smaller than the accumulator ) a transport triggered architecture uses only the move instruction , hence it was originally called a '' move machine '' cryptoleq is a language consisting of one eponymous instruction , is capable of performing general-purpose computation on encrypted programs and is a close relative to subleq 