the instructions themselves reside in memory as a sequence of such integers there exists a class of universal computers with a single instruction based on bit manipulation such as bit copying or bit inversion since their memory model is finite , as is the memory structure used in real computers , those bit manipulation machines are equivalent to real computers rather than to turing machines a bit copying machine , called bitbitjump , copies one bit in memory and passes the execution unconditionally to the address specified by one of the operands of the instruction another machine , called the toga computer , inverts a bit and passes the execution conditionally depending on the result of inversion similar to bitbitjump , a multi-bit copying machine copies several bits at the same time usually , some memory registers ( triggering ports ) within common address space perform an assigned operation when the instruction references them for example , in an oisc using a single memory-to-memory copy instruction , this is done by triggering ports that perform arithmetic and instruction pointer jumps when written to hence , there is no need for an opcode to identify which instruction to execute ; the choice of instruction is inherent in the design of the machine , and an oisc is typically named after the instruction it uses ( e.g each of the above instructions can be used to construct a turing-complete oisc pseudocode : subleq a , b , c ; memb memb - mema ; if ( memb â‰¤ 0 ) goto c conditional branching can be suppressed by setting the third operand equal to the address of the next instruction in sequence a variant is also possible with two operands and an internal accumulator , where the accumulator is subtracted from the memory location specified by the first operand , the following instructions result in the content at location being added to the content at location : ; : subleq a , z subleq z , b subleq z , z the first instruction subtracts the content at location from the content at location ( which is 0 ) and stores the result ( which is the negative of the content at in location the second instruction subtracts this result from , storing in this difference ( which is now the sum of the contents originally at and ; the third instruction restores the value 0 to for example , a branch-if-zero condition can be assembled from the following instructions : ; : subleq b , z , l1 subleq z , z , out l1 : subleq z , z subleq z , b , c out : subleq2 can also be used to synthesize higher-order instructions , although it generally requires more operations for a given task the machine is able to do one operation : take from location x as many counters as there are in location y and transfer them to location z and proceed to next instruction in a reverse subtract and skip if borrow ( rssb ) instruction , the accumulator is subtracted from the memory location and the next instruction is skipped if there was a borrow ( memory location was smaller than the accumulator ) this instruction moves the contents of one memory location to another memory location combining with the current content of the new location : move a to b ; memb : mema ( + , - , , / , 