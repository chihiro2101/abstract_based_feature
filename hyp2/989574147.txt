hereby '' each diagram usually represents objects of a single class and track the different states of its objects through the system '' state diagrams can be used to graphically represent finite-state machines ( also called finite automata ) edges δ : represent transitions from one state to another as caused by the input ( identified by their symbols drawn on the edges ) item δ ( q , a ) p in the definition of the fa means that from the state named q under input symbol a , the transition to the state p occurs in this machine the start state q 0 ∈ q is usually represented by an arrow with no origin pointing to the state mcclusky , introduction to the theory of switching circuits , mcgraw-hill , 1965 the start state is not shown and must be inferred from the text accepting state ( s ) f : if used , for example for accepting automata , f ∈ q is the accept state for a mealy machine , input and output are signified on each edge , separated with a slash '' / '' : '' 1/0 '' denotes the state change upon encountering the symbol '' 1 '' causing the symbol '' 0 '' to be output for a moore machine the state 's output is usually written inside the state 's circle , also separated from the state 's designator with a slash '' / '' for example , if a state has a number of outputs ( e.g s 1 and s 2 are states and s 1 is an accepting state or a final state the diagram type allows the modeling of superstates , orthogonal regions , and activities as part of a state the current state of each cross-functional state machine in the statechart defines the state of the system the harel statechart is equivalent to a state diagram but it improves the readability of the resulting diagram there are other sets of semantics available to represent state diagrams in this case before executing a command the program counter is at some position ( state before the command is executed ) since the program counter is the whole state , it follows that executing the command changed the state however , if the state includes variables , then if those change value , we can be at the same program location with different variable values , meaning in a different state in the program 's state space this results from the state being the program location ( here cycling ) combined with the counter value , which is strictly increasing ( until the overflow ) , so different states are visited in sequence , until the overflow a state in a state machine is an efficient way of specifying a particular behavior , rather than a stage of processing 