state diagrams are used to give an abstract description of the behavior of a system hereby '' each diagram usually represents objects of a single class and track the different states of its objects through the system '' state diagrams can be used to graphically represent finite-state machines ( also called finite automata ) edges δ : represent transitions from one state to another as caused by the input ( identified by their symbols drawn on the edges ) an edge is usually drawn as an arrow directed from the present state to the next state this mapping describes the state transition that is to occur on input of a particular symbol item δ ( q , a ) p in the definition of the fa means that from the state named q under input symbol a , the transition to the state p occurs in this machine the start state q 0 ∈ q is usually represented by an arrow with no origin pointing to the state accepting state ( s ) f : if used , for example for accepting automata , f ∈ q is the accept state sometimes the accept state ( s ) function as '' final '' ( halt , trapped ) states s 1 and s 2 are states and s 1 is an accepting state or a final state the diagram type allows the modeling of superstates , orthogonal regions , and activities as part of a state classic state diagrams require the creation of distinct nodes for every valid combination of parameters that define the state with harel statecharts it is possible to model multiple cross-functional state diagrams within the statechart each of these cross-functional state machines can transition internally without affecting the other state machines in the statechart the harel statechart is equivalent to a state diagram but it improves the readability of the resulting diagram so it is not a state , but when applied to the program 's state , it results in a transition to another state in this case before executing a command the program counter is at some position ( state before the command is executed ) in the previous case , the program would be in the same state , because the whole state is just the program counter , so if the program counterpoints to the same position ( next command ) it suffices to specify that we are in the same state after the overflow the counter becomes 0 again , so the initial state is revisited in the state space , closing a cycle in the state space ( assuming the counter was initialized to 0 ) 