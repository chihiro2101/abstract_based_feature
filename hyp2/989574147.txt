state diagrams are used to give an abstract description of the behavior of a system hereby '' each diagram usually represents objects of a single class and track the different states of its objects through the system '' state diagrams can be used to graphically represent finite-state machines ( also called finite automata ) edges δ : represent transitions from one state to another as caused by the input ( identified by their symbols drawn on the edges ) an edge is usually drawn as an arrow directed from the present state to the next state this mapping describes the state transition that is to occur on input of a particular symbol item δ ( q , a ) p in the definition of the fa means that from the state named q under input symbol a , the transition to the state p occurs in this machine mcclusky , introduction to the theory of switching circuits , mcgraw-hill , 1965 the start state is not shown and must be inferred from the text accepting state ( s ) f : if used , for example for accepting automata , f ∈ q is the accept state sometimes the accept state ( s ) function as '' final '' ( halt , trapped ) states for a deterministic finite automaton ( dfa ) , nondeterministic finite automaton ( nfa ) , generalized nondeterministic finite automaton ( gnfa ) , or moore machine , the input is denoted on each edge for a moore machine the state 's output is usually written inside the state 's circle , also separated from the state 's designator with a slash '' / '' s 1 and s 2 are states and s 1 is an accepting state or a final state classic state diagrams require the creation of distinct nodes for every valid combination of parameters that define the state this can lead to a very large number of nodes and transitions between nodes for all but the simplest of systems ( state and transition explosion ) with harel statecharts it is possible to model multiple cross-functional state diagrams within the statechart the current state of each cross-functional state machine in the statechart defines the state of the system executing the program graph ( parsing and interpreting ) results in a state graph in the previous case , the program would be in the same state , because the whole state is just the program counter , so if the program counterpoints to the same position ( next command ) it suffices to specify that we are in the same state a state in a state machine is an efficient way of specifying a particular behavior , rather than a stage of processing 