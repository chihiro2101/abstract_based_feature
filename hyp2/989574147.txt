state diagrams are used to give an abstract description of the behavior of a system this behavior is analyzed and represented by a series of events that can occur in one or more possible states hereby '' each diagram usually represents objects of a single class and track the different states of its objects through the system '' state diagrams can be used to graphically represent finite-state machines ( also called finite automata ) edges δ : represent transitions from one state to another as caused by the input ( identified by their symbols drawn on the edges ) the start state q 0 ∈ q is usually represented by an arrow with no origin pointing to the state mcclusky , introduction to the theory of switching circuits , mcgraw-hill , 1965 the start state is not shown and must be inferred from the text accepting state ( s ) f : if used , for example for accepting automata , f ∈ q is the accept state for a deterministic finite automaton ( dfa ) , nondeterministic finite automaton ( nfa ) , generalized nondeterministic finite automaton ( gnfa ) , or moore machine , the input is denoted on each edge for a mealy machine , input and output are signified on each edge , separated with a slash '' / '' : '' 1/0 '' denotes the state change upon encountering the symbol '' 1 '' causing the symbol '' 0 '' to be output for example , if a state has a number of outputs ( e.g s 1 and s 2 are states and s 1 is an accepting state or a final state harel statecharts , david harel , statecharts : a visual formalism for complex systems classic state diagrams require the creation of distinct nodes for every valid combination of parameters that define the state the harel statechart is equivalent to a state diagram but it improves the readability of the resulting diagram there are other sets of semantics available to represent state diagrams newcomers to the state machine formalism often confuse state diagrams with flowcharts so it is not a state , but when applied to the program 's state , it results in a transition to another state in this case before executing a command the program counter is at some position ( state before the command is executed ) in the previous case , the program would be in the same state , because the whole state is just the program counter , so if the program counterpoints to the same position ( next command ) it suffices to specify that we are in the same state 